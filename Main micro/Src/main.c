/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include "stm32f051x8.h"
#include "motor_controller.h"
#include "chassis.h"
#include "Bluetooth_USART2.h"
#include "IR.h"
#include "Global_Stop_Causes.h"
#include "uart_commands.h"
#include "stops.h"
#include "control.h"

uint32_t SystemCoreClock = 8000000;  // define la frecuencia

#define RX_BUF_SIZE 32
#define MAX_MENSAJE 20

IRSensor IR_MostOuterRight = { GPIOB, 9};
IRSensor IR_OuterRight = { GPIOB, 10};
IRSensor IR_CenterRight = { GPIOB, 11};
IRSensor IR_Center = { GPIOB, 12};
IRSensor IR_CenterLeft = { GPIOB, 13};
IRSensor IR_OuterLeft = { GPIOB, 14};
IRSensor IR_MostOuterLeft = { GPIOB, 15};

volatile bool emergencyStop = 0;
volatile uint8_t WaitForAnswer = 0;
volatile int emergencyCounter = 0;
volatile int error_0_counter = 0;

volatile bool sensorStates[7];

bool justEnteredLineMode;
bool dis_detected;
int lineFollowerMode = 0;

float forward_speed_LF = 0; // Choose based on desired speed (0.0 to 1.0)
float temp_P = 0.0925;
float temp_I = 0;
float temp_D = 0.45;

volatile uint8_t current_temperature = 0;
volatile uint8_t current_color = 0;
volatile uint8_t compare_color = 0;
Stop* currentStop;

volatile uint8_t bytes_in_terminal;
volatile uint8_t frame[4];
volatile uint8_t ack;
volatile uint8_t cmd;
volatile uint8_t sub_cmd;
volatile uint8_t data;

volatile uint8_t  run_enabled = 0;
volatile uint32_t run_deadline = 0;
volatile uint8_t  wait_enabled = 0;
volatile uint32_t run_wait_deadline = 0;













int main(void) {
	USART2_Init_Interrupt();
	System_Ready_Indicator();
	StopCauses_Init();

	UART_SetRole(ROLE_MASTER);   // define el rol
    USART1_Init();               // inicializa UART

	MotorController motorA;
	MotorController motorB;
	CHASSIS agv;

	// Initialize motor (Dir1, Dir2, PWM, BrakePin)
	Motor_Init(&motorA, 6, 7, 8, 5);
	Motor_Init(&motorB, 10, 11, 9, 4);
	Motor_Invert(&motorB, 1);
	Init_Chassis(&agv,motorA,motorB);
	set_AdvanceInverted(&agv, 1);

	LineFollower Follower = {IR_MostOuterRight, IR_OuterRight, IR_CenterRight, IR_Center, IR_CenterLeft, IR_OuterLeft, IR_MostOuterLeft};
	LineFollower_Init(&Follower);

	Treat_Failure_Flags = (Treat_Failure_Flags_t){1,1,1,1,1,1,1};

	control_init();





   // Test sequence
    while (1) {

    	if (rx_ready == 1) {
			USART2_HandleMessage(&agv);
		}

		if ((!emergencyStop) & stop_flags.bluetooth_flag & (!stop_flags.distance1_flag) & (!stop_flags.distance2_flag) & (!stop_flags.color_flag)) {

			Treat_Failure_Flags = (Treat_Failure_Flags_t){1,1,1,1,1,1,1};

			if(run_enabled == 1) {
				control_reset_all();               // <—— LIMPIA TODO ANTES DE EMPEZAR
				run_enabled = 0;
			}

			if(wait_enabled == 1) {
				control_reset_all();               // <—— LIMPIA TODO ANTES DE EMPEZAR
				wait_enabled = 0;
			}

			if ((lineFollowerMode == 0)) {
				apply_CurrentSpeedsToMotors_noBrake_if_0(&agv);
			} else if ((lineFollowerMode == 1)) {
				if (justEnteredLineMode) {
				    resetPID();  // integral = 0, last_error = 0
				    justEnteredLineMode = 0;
				}
				apply_CurrentSpeedsToMotors_noBrake_if_0(&agv);
				LineFollower_FollowLine(&Follower, &agv, forward_speed_LF);
			} else if (lineFollowerMode == 2) {
				if (justEnteredLineMode) {
				    resetPID();  // integral = 0, last_error = 0
				    justEnteredLineMode = 0;
				}
				LineFollower_FollowLine_PID(&Follower, &agv, forward_speed_LF, temp_P, temp_I, temp_D);
			}
		} else {
			if ((stop_flags.distance1_flag) || (stop_flags.distance2_flag)) {
				pause_Chassis(&agv);
			}

			/*
			if (WaitForAnswer == 0) { // Enviar solo una vez y esperar respuesta
				pause_Chassis(&agv);
			    if (stop_flags.temperature_flag && Treat_Failure_Flags.temperature_Fail_cmd)
			    {
			        // Enviar comando de temperatura
			    	Master_RequestTemperature();
			    	WaitForAnswer = 1;
			    } else if (stop_flags.color_flag && Treat_Failure_Flags.color_Fail_cmd)
			    {
			        // Enviar comando de color
			    	Master_RequestColor();
			    	WaitForAnswer = 1;
			    }
			} */

			/* bytes_in_terminal = USART1_AvailableBytes(); */

			/*
			if ((WaitForAnswer == 1) && (bytes_in_terminal >= 4)) {
				pause_Chassis(&agv);
			    for (uint8_t i = 0; i < 4; i++)
			        frame[i] = USART1_ReadByte();   // leer realmente los bytes (no peek)

			    uint8_t ack     = frame[0];
			    uint8_t cmd     = frame[1];
			    uint8_t sub_cmd = frame[2];
			    uint8_t data    = frame[3];

			    if (ack == ACKNOWLEDGE)
			    {
			        if (cmd == C_TEMPERATURE)
			        {
			        	if (sub_cmd == RETRIEVE_TEMP){
			        		current_temperature = data;
			        		Treat_Failure_Flags.temperature_Fail_cmd = 0;
			        	}
			        } else if (cmd == C_COLOR)
			        {
			        	if (sub_cmd == RETRIEVE_COLOR){
			        		current_color = data;
			        		Treat_Failure_Flags.color_Fail_cmd = 0;
			        	}
			        }

			        WaitForAnswer = 0;

			    }

			    USART1_ClearBuffer();  // limpia cualquier residuo
			}
			*/

			if (lineFollowerMode == 1 && stop_flags.color_flag) {

				Update_ColorFlags();
				int k = -1; // índice de la parada que se revisará

				if (stop_flags.red_flag) {
				    current_color = COLOR_RED; // rojo
				    k = 0; // primera instancia
				} else if (stop_flags.green_flag) {
				    current_color = COLOR_GREEN; // verde
				    k = 1; // segunda instancia
				} else if (stop_flags.blue_flag) {
				    current_color = COLOR_BLUE; // azul
				    k = 2; // tercera instancia
				} else {
				    current_color = COLOR_INVALID; // sin color detectado
				    break;
				}

			    // Solo si hay un color válido
			    if (k >= 0 && k < NUM_PARADAS) {
			        // Revisar el tercer valor (waitFlag)
			        if (Paradas[k].waitFlag == 1) {
			        	//CASO 1: Color si debe esperar
			        	if(wait_enabled == 0){
			        		wait_enabled = 1;
			        		run_wait_deadline = millis() + 10000u;  // 10 s
			        	}
			        } else {
			        	if(run_enabled == 0) {
			        		control_reset_all();               // <—— LIMPIA TODO ANTES DE EMPEZAR
							run_enabled = 1;
							run_deadline = millis() + 4000u;  // 40 s
			        	}
			        }
			    }
			}


			// 2) Si estamos corriendo, actualizar control...
			if (run_enabled) {
				control_update();

				// 3) ¿se acabó la ventana de 10 s?
				if ((int32_t)(millis() - run_deadline) >= 0) {
					run_enabled = 0;
					control_reset_all();           // <—— SE DETIENE Y QUEDA LIMPIO
				}
			}


			if (wait_enabled) {
				// 1) ¿se acabó la ventana de 10 s?
				if ((int32_t)(millis() - run_wait_deadline) >= 0) {
					wait_enabled = 0;
					run_enabled = 1;
					run_deadline = millis() + 4000u;  // 40 s
				}
			}

		}
	}
}

